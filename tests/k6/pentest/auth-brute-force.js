/**
 * GAUZIAN Authentication Brute-Force Test (k6)
 *
 * Tests rate limiting and brute-force protection on login endpoint.
 *
 * Usage:
 *   k6 run tests/k6/pentest/auth-brute-force.js
 *
 * Expected Behavior:
 *   - Traefik rate-limit middleware should return HTTP 429 after 100 req/s
 *   - Application should implement per-user rate limiting
 *   - Failed login attempts should not leak timing information
 */

import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate, Trend, Counter } from 'k6/metrics';

// Custom metrics
const failedLogins = new Counter('failed_logins');
const rateLimited = new Counter('rate_limited_requests');
const loginDuration = new Trend('login_request_duration');
const timingVariance = new Trend('login_timing_variance');

// Test configuration
export const options = {
  stages: [
    { duration: '10s', target: 50 },   // Ramp up to 50 VUs
    { duration: '30s', target: 100 },  // Increase to 100 VUs (trigger rate limit)
    { duration: '20s', target: 200 },  // Spike to 200 VUs (heavy stress)
    { duration: '10s', target: 0 },    // Ramp down
  ],
  thresholds: {
    'rate_limited_requests': ['count > 0'],  // Expect rate limiting to trigger
    'http_req_failed': ['rate < 0.5'],       // Less than 50% failures (excluding 429s)
    'http_req_duration': ['p(95) < 2000'],   // 95% of requests under 2s
  },
};

const BASE_URL = __ENV.API_URL || 'https://gauzian.pupin.fr/api';
const TEST_EMAIL = __ENV.TEST_EMAIL || 'brute_force_test@example.com';

export default function () {
  const payload = JSON.stringify({
    email: TEST_EMAIL,
    password: `wrong_password_${__VU}_${__ITER}`,  // Unique wrong password per attempt
  });

  const params = {
    headers: {
      'Content-Type': 'application/json',
    },
  };

  const startTime = new Date();
  const response = http.post(`${BASE_URL}/login`, payload, params);
  const endTime = new Date();
  const duration = endTime - startTime;

  loginDuration.add(duration);

  // Check for rate limiting
  const isRateLimited = check(response, {
    'rate limited (HTTP 429)': (r) => r.status === 429,
  });

  if (isRateLimited) {
    rateLimited.add(1);
    console.log(`[VU ${__VU}] Rate limited at iteration ${__ITER} (HTTP 429)`);
  }

  // Check for failed login (expected)
  const isUnauthorized = check(response, {
    'unauthorized (HTTP 401)': (r) => r.status === 401,
  });

  if (isUnauthorized) {
    failedLogins.add(1);
  }

  // Check response time consistency (timing attack detection)
  // All failed logins should take approximately the same time
  if (response.status === 401) {
    const variance = Math.abs(duration - 100);  // Expected ~100ms baseline
    timingVariance.add(variance);

    if (variance > 500) {  // More than 500ms variance
      console.warn(`[VU ${__VU}] Timing variance detected: ${variance}ms (potential timing attack vector)`);
    }
  }

  // Check for unexpected responses
  check(response, {
    'status is 401, 429, or 200': (r) => [200, 401, 429].includes(r.status),
  });

  // Log unexpected status codes
  if (![200, 401, 429].includes(response.status)) {
    console.error(`[VU ${__VU}] Unexpected status: ${response.status} - ${response.body}`);
  }

  // Small delay to avoid overwhelming the server
  sleep(0.1);
}

export function handleSummary(data) {
  return {
    'stdout': textSummary(data, { indent: ' ', enableColors: true }),
    './tests/security/reports/k6_brute_force_report.json': JSON.stringify(data),
  };
}

function textSummary(data, options) {
  const indent = options.indent || '';
  const colors = options.enableColors ? {
    reset: '\x1b[0m',
    bold: '\x1b[1m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    red: '\x1b[31m',
    cyan: '\x1b[36m',
  } : {
    reset: '', bold: '', green: '', yellow: '', red: '', cyan: '',
  };

  let summary = `\n${colors.bold}${colors.cyan}================================${colors.reset}\n`;
  summary += `${colors.bold}  Brute-Force Test Summary${colors.reset}\n`;
  summary += `${colors.bold}${colors.cyan}================================${colors.reset}\n\n`;

  // Extract metrics
  const metrics = data.metrics;

  summary += `${colors.bold}Total Requests:${colors.reset} ${metrics.http_reqs.values.count}\n`;
  summary += `${colors.bold}Failed Logins (401):${colors.reset} ${metrics.failed_logins.values.count}\n`;
  summary += `${colors.bold}Rate Limited (429):${colors.reset} ${metrics.rate_limited_requests.values.count}\n`;
  summary += `${colors.bold}Request Duration (avg):${colors.reset} ${metrics.http_req_duration.values.avg.toFixed(2)}ms\n`;
  summary += `${colors.bold}Request Duration (p95):${colors.reset} ${metrics.http_req_duration.values['p(95)'].toFixed(2)}ms\n`;

  // Timing variance analysis
  if (metrics.login_timing_variance) {
    const avgVariance = metrics.login_timing_variance.values.avg;
    summary += `${colors.bold}Timing Variance (avg):${colors.reset} ${avgVariance.toFixed(2)}ms`;

    if (avgVariance > 500) {
      summary += ` ${colors.red}⚠ HIGH VARIANCE (timing attack risk)${colors.reset}\n`;
    } else {
      summary += ` ${colors.green}✓ Low variance${colors.reset}\n`;
    }
  }

  summary += `\n${colors.bold}Security Assessment:${colors.reset}\n`;

  // Rate limiting check
  if (metrics.rate_limited_requests.values.count > 0) {
    summary += `${colors.green}✓ Rate limiting is active (${metrics.rate_limited_requests.values.count} requests limited)${colors.reset}\n`;
  } else {
    summary += `${colors.red}✗ No rate limiting detected (potential vulnerability)${colors.reset}\n`;
  }

  // Timing attack check
  const avgVariance = metrics.login_timing_variance?.values.avg || 0;
  if (avgVariance < 500) {
    summary += `${colors.green}✓ Timing attack protection (low variance)${colors.reset}\n`;
  } else {
    summary += `${colors.yellow}⚠ Potential timing attack vector (high variance)${colors.reset}\n`;
  }

  summary += `\n${colors.cyan}================================${colors.reset}\n\n`;

  return summary;
}
