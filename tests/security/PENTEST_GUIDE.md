# GAUZIAN Penetration Testing Guide

**Version:** 1.0
**Last Updated:** 2026-02-17
**Target:** https://gauzian.pupin.fr
**Technology Stack:** Rust (Axum), PostgreSQL, Redis, MinIO S3

---

## Table of Contents

1. [Overview](#overview)
2. [Security Architecture Analysis](#security-architecture-analysis)
3. [Attack Surface](#attack-surface)
4. [Testing Tools](#testing-tools)
5. [Test Execution Procedures](#test-execution-procedures)
6. [Vulnerability Categories](#vulnerability-categories)
7. [Remediation Guidelines](#remediation-guidelines)
8. [Pre-Deployment Security Checklist](#pre-deployment-security-checklist)

---

## Overview

GAUZIAN is a zero-knowledge cloud storage platform with end-to-end encryption (E2EE). The backend never sees plaintext data - all encryption/decryption happens client-side.

### Security Posture Goals

- **Zero-Knowledge Architecture**: Server cannot decrypt user data
- **Defense in Depth**: Multiple security layers (authentication, authorization, encryption, rate limiting)
- **Fail-Closed**: On service failures (Redis down), deny access rather than bypass security
- **OWASP Top 10 Coverage**: Comprehensive protection against common vulnerabilities

### Critical Assets

1. **User Credentials** - Encrypted private keys, password hashes, JWT secrets
2. **File Metadata** - Encrypted file names, sizes, folder structures
3. **Encrypted Data Keys** - RSA-wrapped AES keys for file encryption
4. **S3 Chunks** - Encrypted file content in MinIO
5. **Access Control** - Permissions matrices (file_access, folder_access tables)

---

## Security Architecture Analysis

### Authentication Flow

```
Client Request
  ↓
JWT Extraction (Cookie "auth_token" OR Header "Authorization: Bearer <token>")
  ↓
JWT Verification (HMAC-SHA256, 10-day expiration)
  ↓
Redis Blacklist Check (FAIL-CLOSED: if Redis down → deny access)
  ↓
Claims Extraction (user_id, role, jti)
  ↓
Authorized Request
```

**Strengths:**
- ✅ HMAC-SHA256 signature prevents tampering
- ✅ Short-lived tokens (10 days)
- ✅ Fail-closed on Redis unavailability
- ✅ Unique JTI (JWT ID) for revocation

**Potential Weaknesses:**
- ⚠️ JWT secret strength depends on `JWT_SECRET` env var (must be 256+ bits)
- ⚠️ No refresh token mechanism (forces re-login after 10 days)
- ⚠️ Logout relies on Redis (persistent attack if Redis compromised)

---

### Password Hashing

**Current Implementation:**
- **New Users**: Argon2id (OWASP recommended)
- **Legacy Users**: SHA256 + salt (backward compatibility)

**Strengths:**
- ✅ Argon2id is memory-hard and resistant to GPU attacks
- ✅ Per-user random salts

**Potential Weaknesses:**
- ⚠️ SHA256 legacy hashes are vulnerable to rainbow tables if salt is weak
- ⚠️ No password complexity enforcement in backend (relies on frontend validation)

---

### End-to-End Encryption (E2EE)

**Cryptographic Stack:**
- **RSA-4096** (OAEP, SHA-256) - Asymmetric key wrapping
- **AES-256-GCM** - Symmetric encryption for files
- **PBKDF2** (SHA-256, 310k iterations) - Password-based key derivation

**File Sharing Workflow:**
```
Owner uploads file
  ↓
1. Generate random file_key (AES-256)
2. Encrypt file chunks with file_key
3. Encrypt file_key with owner's public_key (RSA-4096)
4. Store encrypted chunks in S3
5. Store encrypted_file_key in file_access table
  ↓
Share with recipient
  ↓
1. Owner decrypts file_key with private_key
2. Owner re-encrypts file_key with recipient's public_key
3. Store encrypted_file_key in file_access (recipient_user_id)
  ↓
Recipient downloads file
  ↓
1. Fetch encrypted_file_key from file_access
2. Decrypt file_key with private_key
3. Decrypt chunks with file_key
```

**Strengths:**
- ✅ Server never sees plaintext file_key or file content
- ✅ RSA-4096 is quantum-resistant (for now)
- ✅ GCM mode provides authentication (prevents tampering)

**Potential Weaknesses:**
- ⚠️ Private key stored encrypted in DB (vulnerable if password weak)
- ⚠️ No key rotation mechanism
- ⚠️ Metadata encryption relies on client-side implementation correctness

---

### Authorization Model

**Access Levels:**
- `owner` - Full control (read, write, delete, share)
- `editor` - Read + write
- `viewer` - Read-only

**Enforcement:**
- All drive endpoints check `file_access` or `folder_access` tables
- Horizontal privilege escalation prevented by `user_id` checks
- Vertical privilege escalation prevented by `access_level` checks

**Potential Weaknesses:**
- ⚠️ IDOR (Insecure Direct Object Reference) if UUID validation is bypassed
- ⚠️ Race conditions in share/revoke operations
- ⚠️ No audit logging of access attempts

---

## Attack Surface

### Public Endpoints (No Authentication Required)

| Endpoint | Method | Parameters | Attack Vectors |
|----------|--------|------------|----------------|
| `/api/login` | POST | `email`, `password` | Brute-force, credential stuffing, timing attacks |
| `/api/register` | POST | `username`, `email`, `password`, crypto keys | User enumeration, weak password acceptance, duplicate emails |
| `/api/contacts/get_public_key/:email` | GET | `email` (path param) | User enumeration, email validation bypass, SQL injection |

### Protected Endpoints (JWT Required)

#### Authentication Module

| Endpoint | Method | Parameters | Attack Vectors |
|----------|--------|------------|----------------|
| `/api/logout` | POST | - | Token replay after logout, Redis race conditions |
| `/api/autologin` | GET | - | Token validation bypass |
| `/api/info` | GET | - | Information disclosure |

#### Drive Module (32 Routes)

**File Operations:**

| Endpoint | Method | Parameters | Attack Vectors |
|----------|--------|------------|----------------|
| `/api/drive/initialize_file` | POST | `size`, `encrypted_metadata`, `mime_type`, `folder_id`, `encrypted_file_key` | UUID injection, quota bypass, folder_id manipulation |
| `/api/drive/upload_chunk` | POST | `file_id`, `index`, `chunk_data` (base64), `iv` | Path traversal, chunk index manipulation, DoS (large chunks) |
| `/api/drive/finalize_upload/:file_id/:etat` | POST | `file_id`, `etat` (path) | Premature finalization, SQL injection in path params |
| `/api/drive/file/:file_id` | GET | `file_id` | IDOR, UUID enumeration |
| `/api/drive/download/:file_id` | GET | `file_id` | IDOR, unauthorized access |
| `/api/drive/download_chunk/:s3_key` | GET | `s3_key` | Path traversal, S3 key enumeration |
| `/api/drive/delete_file` | POST | `file_id` | IDOR, cascade delete abuse |
| `/api/drive/rename_file` | POST | `file_id`, `new_name` | IDOR, metadata injection |
| `/api/drive/move_file` | POST | `file_id`, `new_folder_id` | IDOR, folder ownership bypass |
| `/api/drive/restore_file` | POST | `file_id` | IDOR, trash manipulation |
| `/api/drive/share_file` | POST | `file_id`, `recipient_user_id`, `encrypted_file_key`, `access_level` | IDOR, privilege escalation, key injection |
| `/api/drive/propagate_file_access` | POST | `file_id` | IDOR, permission escalation |
| `/api/drive/revoke-access` | POST | `file_id`, `user_id` | IDOR, incomplete revocation |

**Folder Operations:**

| Endpoint | Method | Parameters | Attack Vectors |
|----------|--------|------------|----------------|
| `/api/drive/create_folder` | POST | `name`, `parent_id`, `encrypted_metadata` | UUID injection, nested folder DoS |
| `/api/drive/get_folder/:folder_id` | GET | `folder_id` | IDOR, metadata disclosure |
| `/api/drive/folder_contents/:folder_id` | GET | `folder_id` | IDOR, recursive enumeration |
| `/api/drive/delete_folder` | POST | `folder_id` | IDOR, cascade delete abuse |
| `/api/drive/share_folder` | POST | `folder_id`, `target_user_email`, `access_level` | IDOR, email validation bypass |
| `/api/drive/empty_trash` | POST | - | DoS (mass deletion), race conditions |

**Critical Endpoints (High Risk):**
1. `/api/drive/download_chunk/:s3_key` - Direct S3 access (path traversal risk)
2. `/api/drive/share_file` - Permission escalation risk
3. `/api/drive/propagate_folder_access` - Recursive permission manipulation
4. `/api/drive/empty_trash` - Irreversible data loss

---

## Testing Tools

### 1. SQLMap (SQL Injection)

**Purpose:** Automated SQL injection testing against PostgreSQL backend.

**Configuration:**
```bash
--dbms=PostgreSQL        # Target DBMS
--level=3                # Thoroughness (1-5, higher = more payloads)
--risk=2                 # Aggressive tests (1-3, higher = more invasive)
--batch                  # Non-interactive mode
--flush-session          # Clear cached results
--force-ssl              # HTTPS required
```

**Usage:**
```bash
# Quick test (public endpoints)
./tests/security/sqlmap_quick_test.sh

# Full test (all endpoints, requires JWT)
./tests/security/sqlmap_test.sh
```

**Custom Payloads for UUID Injection:**
```sql
' OR id='00000000-0000-0000-0000-000000000000' --
' UNION SELECT id, encrypted_metadata FROM files --
```

---

### 2. k6 (Load Testing & Rate Limiting)

**Purpose:** Test performance, rate limiting, and DoS resilience.

**Scenarios:**
- **Login Brute-Force:** 1000 attempts/sec for 60s
- **File Upload DoS:** 100 concurrent chunked uploads
- **Recursive Folder Enumeration:** Deep folder traversal

**Usage:**
```bash
# Authentication stress test
k6 run tests/k6/pentest/auth-brute-force.js

# Upload DoS test
k6 run --vus 100 --duration 5m tests/k6/pentest/upload-dos.js

# Rate limiting validation
k6 run tests/k6/pentest/rate-limit-validation.js
```

---

### 3. OWASP ZAP (Automated Vulnerability Scanning)

**Purpose:** Automated detection of OWASP Top 10 vulnerabilities.

**Configuration:**
```bash
# Passive scan (safe, no attacks)
zap-cli quick-scan --self-contained https://gauzian.pupin.fr

# Active scan (aggressive, use with caution)
zap-cli active-scan --recursive https://gauzian.pupin.fr/api
```

**Custom Scan Policy:**
- Enable: SQL Injection, XSS, Path Traversal, Authentication Bypass
- Disable: Buffer Overflow (not applicable to Rust)

---

### 4. Burp Suite (Manual Testing)

**Purpose:** Manual testing, request tampering, session analysis.

**Key Features:**
- Intercept and modify JWT tokens
- Test authorization bypass (change user_id in claims)
- Fuzzing UUID parameters
- Session token analysis

**Setup:**
```bash
# Configure proxy
export HTTP_PROXY=http://127.0.0.1:8080
export HTTPS_PROXY=http://127.0.0.1:8080

# Add CA certificate to browser
# Import Burp's CA cert from http://burp/cert
```

---

### 5. Custom Python Scripts

**Purpose:** Business logic testing, multi-step attacks, E2EE validation.

**Scripts:**
- `auth_bypass_test.py` - JWT manipulation, blacklist race conditions
- `idor_enumeration.py` - Automated IDOR testing across all file/folder IDs
- `e2ee_validation.py` - Verify server cannot decrypt metadata/files
- `privilege_escalation.py` - Test viewer → editor → owner escalation

---

## Test Execution Procedures

### Phase 1: Information Gathering (Passive)

**Objective:** Map attack surface without triggering defenses.

```bash
# 1. Endpoint discovery
curl -s https://gauzian.pupin.fr/api/ | jq .

# 2. CORS policy analysis
curl -H "Origin: https://evil.com" \
     -H "Access-Control-Request-Method: POST" \
     -H "Access-Control-Request-Headers: Authorization" \
     -X OPTIONS https://gauzian.pupin.fr/api/login -v

# 3. SSL/TLS configuration
nmap --script ssl-enum-ciphers -p 443 gauzian.pupin.fr

# 4. Header analysis
curl -I https://gauzian.pupin.fr

# Expected security headers:
# - Strict-Transport-Security: max-age=31536000
# - X-Content-Type-Options: nosniff
# - X-Frame-Options: DENY
# - Content-Security-Policy: default-src 'self'
```

---

### Phase 2: Authentication Testing

#### Test 1: Brute-Force Protection

**Objective:** Verify rate limiting on login endpoint.

```bash
# Run k6 brute-force script
k6 run tests/k6/pentest/auth-brute-force.js

# Expected result:
# - HTTP 429 (Too Many Requests) after N attempts
# - Traefik rate-limit middleware: 100 req/s
```

**Manual Test:**
```bash
for i in {1..200}; do
  curl -X POST https://gauzian.pupin.fr/api/login \
    -H "Content-Type: application/json" \
    -d '{"email":"test@example.com","password":"wrong'$i'"}' \
    -w "%{http_code}\n" -o /dev/null
done | sort | uniq -c

# Should see transition from 401 → 429
```

---

#### Test 2: JWT Secret Strength

**Objective:** Ensure JWT_SECRET has sufficient entropy.

```bash
# Check secret length (should be 256+ bits = 64 hex chars)
kubectl get secret backend-secrets -n gauzian-v2 -o json | \
  jq -r '.data.JWT_SECRET' | base64 -d | wc -c

# Expected: ≥ 32 bytes (256 bits)
```

**Offline Attack Simulation:**
```bash
# Capture a valid JWT
JWT="<captured_token>"

# Try brute-force with hashcat (will fail if secret is strong)
hashcat -m 16500 -a 3 "$JWT" ?a?a?a?a?a?a?a?a
```

---

#### Test 3: Token Revocation

**Objective:** Verify logout blacklists JWT in Redis.

```bash
# Run custom test script
python3 tests/security/scripts/jwt_revocation_test.py

# Test steps:
# 1. Login → get JWT
# 2. Access protected endpoint (success)
# 3. Logout
# 4. Access protected endpoint (should fail with 401)
# 5. Verify token exists in Redis: GET revoked:<jti>
```

---

#### Test 4: Session Fixation

**Objective:** Ensure new JTI is generated on login.

```bash
# Login twice with same credentials
TOKEN1=$(curl -s -X POST https://gauzian.pupin.fr/api/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"SecurePass123!"}' | \
  jq -r '.token')

TOKEN2=$(curl -s -X POST https://gauzian.pupin.fr/api/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"SecurePass123!"}' | \
  jq -r '.token')

# Decode JTI from both tokens
JTI1=$(echo $TOKEN1 | jq -R 'split(".") | .[1] | @base64d' | jq -r '.jti')
JTI2=$(echo $TOKEN2 | jq -R 'split(".") | .[1] | @base64d' | jq -r '.jti')

# Verify they're different
[ "$JTI1" != "$JTI2" ] && echo "✅ PASS: Unique JTI per login" || echo "❌ FAIL: Session fixation risk"
```

---

### Phase 3: Authorization Testing

#### Test 5: IDOR (Insecure Direct Object References)

**Objective:** Verify users cannot access files/folders they don't own.

```bash
# Run automated IDOR script
python3 tests/security/scripts/idor_enumeration.py \
  --target https://gauzian.pupin.fr \
  --users user1@example.com,user2@example.com \
  --passwords Pass1,Pass2

# Test cases:
# 1. User1 creates file → User2 tries to access (should fail)
# 2. User1 shares file with User2 (viewer) → User2 tries to delete (should fail)
# 3. User1 tries to access User2's file by guessing UUID (should fail)
```

---

#### Test 6: Privilege Escalation (Horizontal)

**Objective:** Verify `viewer` cannot perform `editor`/`owner` actions.

```bash
# Setup:
# 1. User1 creates file
# 2. User1 shares file with User2 as "viewer"
# 3. User2 attempts to rename/delete file

curl -X POST https://gauzian.pupin.fr/api/drive/rename_file \
  -H "Cookie: auth_token=$USER2_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"file_id":"<file_id>","new_name":"hacked.txt"}' \
  -w "%{http_code}\n"

# Expected: 403 Forbidden (or 401 if access_level check returns not found)
```

---

#### Test 7: Privilege Escalation (Vertical)

**Objective:** Verify regular users cannot access admin endpoints.

```bash
# Check if admin endpoints exist
curl -X GET https://gauzian.pupin.fr/api/admin/users \
  -H "Cookie: auth_token=$REGULAR_USER_TOKEN" \
  -w "%{http_code}\n"

# Expected: 404 (endpoint doesn't exist) or 403 (forbidden)
```

---

### Phase 4: Injection Testing

#### Test 8: SQL Injection (SQLMap)

**Objective:** Detect SQL injection vulnerabilities in all endpoints.

```bash
# Run full SQLMap suite
./tests/security/sqlmap_test.sh

# Manual test on critical endpoint
sqlmap -u "https://gauzian.pupin.fr/api/drive/file/00000000-0000-0000-0000-000000000000" \
  --cookie="auth_token=$JWT" \
  --dbms=PostgreSQL \
  --level=5 \
  --risk=3 \
  --batch

# Expected: No injections found (SQLx compile-time query validation)
```

---

#### Test 9: NoSQL Injection (Redis)

**Objective:** Test Redis injection in blacklist operations.

**Attack Vector:** Manipulate JTI to inject Redis commands.

```bash
# Malicious JWT with crafted JTI
{
  "id": "...",
  "role": "user",
  "jti": "abc\nDEL revoked:*\n",  # Try to delete all blacklisted tokens
  "exp": 1234567890
}

# Sign with captured/leaked JWT_SECRET
# Attempt logout to trigger Redis SET command

# Expected: Sanitization in services.rs::blacklist_token()
# Redis library should escape newlines
```

---

#### Test 10: Command Injection (S3 Operations)

**Objective:** Test path traversal in S3 key generation.

```bash
# Try to upload file with malicious s3_key
curl -X POST https://gauzian.pupin.fr/api/drive/upload_chunk \
  -H "Cookie: auth_token=$JWT" \
  -H "Content-Type: application/json" \
  -d '{
    "file_id": "valid-uuid",
    "index": 0,
    "chunk_data": "dGVzdA==",
    "iv": "../../../etc/passwd"
  }'

# Expected: Rejected (IV validation, no path traversal in S3 key)
```

---

### Phase 5: Cryptographic Testing

#### Test 11: E2EE Validation (Server Cannot Decrypt)

**Objective:** Verify server never sees plaintext metadata.

```bash
# Run E2EE validation script
python3 tests/security/scripts/e2ee_validation.py

# Test steps:
# 1. Upload file with encrypted_metadata
# 2. Capture network traffic with tcpdump
# 3. Search for plaintext filename in packets
# 4. Search for plaintext filename in PostgreSQL logs
# 5. Search for plaintext filename in MinIO S3 logs

# Expected: No plaintext found anywhere on server
```

---

#### Test 12: Weak Cryptographic Algorithms

**Objective:** Ensure no weak algorithms are used.

```bash
# Check TLS configuration
testssl.sh https://gauzian.pupin.fr

# Expected:
# ✅ TLS 1.3 supported
# ❌ SSLv3, TLS 1.0, TLS 1.1 disabled
# ✅ Strong ciphers only (AES-256-GCM, ChaCha20-Poly1305)
# ❌ RC4, DES, 3DES disabled

# Check password hashing
# Inspect database for Argon2 hashes
psql -c "SELECT username, LEFT(password_hash, 20) FROM users LIMIT 5;"

# Expected: $argon2id$ prefix (not MD5/SHA1/plain SHA256)
```

---

### Phase 6: Business Logic Testing

#### Test 13: Quota Bypass

**Objective:** Verify file size limits are enforced.

```bash
# Attempt to upload 10GB file (assuming quota is 5GB)
python3 tests/security/scripts/quota_bypass_test.py \
  --file-size 10737418240 \
  --target https://gauzian.pupin.fr

# Expected: 413 Payload Too Large or 400 Bad Request (quota exceeded)
```

---

#### Test 14: Race Conditions (Share/Revoke)

**Objective:** Test concurrent share/revoke operations.

```bash
# Run race condition test
python3 tests/security/scripts/race_condition_test.py \
  --operation share_revoke \
  --threads 50 \
  --iterations 100

# Test scenario:
# - Thread 1: Share file with User2
# - Thread 2: Revoke access from User2
# - Repeat 100 times concurrently

# Expected: Consistent state (no partial shares)
```

---

### Phase 7: Denial of Service (DoS)

#### Test 15: Resource Exhaustion (DB Connections)

**Objective:** Test connection pool limits.

```bash
# Simulate 100 concurrent DB-intensive requests
k6 run tests/k6/pentest/db-connection-exhaustion.js

# Expected:
# - HPA scales backend pods (2 → 10)
# - Some requests may get 503 (Service Unavailable)
# - No database crashes
# - Connection pool remains healthy after test
```

---

#### Test 16: Recursive Folder Bomb

**Objective:** Test protection against deeply nested folders.

```bash
# Create 1000 nested folders
python3 tests/security/scripts/folder_bomb_test.py \
  --depth 1000 \
  --target https://gauzian.pupin.fr

# Expected:
# - Max depth limit enforced (e.g., 100 levels)
# - Request rejected with 400 Bad Request
```

---

## Vulnerability Categories

### OWASP Top 10 (2025) Coverage

| # | Vulnerability | Status | Mitigation |
|---|---------------|--------|------------|
| A01 | Broken Access Control | ⚠️ **Test Required** | Authorization checks in all handlers |
| A02 | Cryptographic Failures | ✅ **Mitigated** | Argon2id hashing, E2EE, strong TLS |
| A03 | Injection | ✅ **Mitigated** | SQLx compile-time queries, Redis param escaping |
| A04 | Insecure Design | ⚠️ **Partial** | E2EE architecture, but no key rotation |
| A05 | Security Misconfiguration | ⚠️ **Test Required** | K8s security policies, secrets management |
| A06 | Vulnerable Components | ⚠️ **Monitor** | Regular `cargo audit`, Docker base image updates |
| A07 | ID & Auth Failures | ⚠️ **Test Required** | JWT with revocation, MFA not implemented |
| A08 | Data Integrity Failures | ✅ **Mitigated** | AES-GCM authentication, TLS |
| A09 | Logging & Monitoring | ⚠️ **Partial** | Prometheus metrics, but no audit logs |
| A10 | SSRF | ✅ **Low Risk** | No outbound HTTP requests from user input |

---

## Remediation Guidelines

### High Priority

#### 1. Implement Rate Limiting Per User (Not Just IP)

**Current:** Traefik rate-limits by IP (100 req/s).
**Issue:** Attacker with multiple IPs can bypass.

**Fix:**
```rust
// Add middleware in routes.rs
use tower_governor::{GovernorLayer, governor::GovernorConfigBuilder};

let governor_config = GovernorConfigBuilder::default()
    .per_millisecond(100)  // 100 requests
    .burst_size(10)        // Burst of 10
    .key_extractor(|req: &http::Request<_>| {
        // Extract user_id from JWT claims
        extract_user_id_from_request(req)
    })
    .finish()
    .unwrap();

Router::new()
    .layer(GovernorLayer { config: governor_config })
    // ...
```

---

#### 2. Add Audit Logging for Sensitive Operations

**Current:** No audit trail for file access, sharing, deletion.

**Fix:**
```rust
// Create audit_logs table
sqlx::query!(
    "INSERT INTO audit_logs (user_id, action, resource_type, resource_id, ip_address, metadata, created_at)
     VALUES ($1, $2, $3, $4, $5, $6, NOW())",
    user_id,
    "file_accessed",
    "file",
    file_id,
    client_ip,
    json!({"access_level": "viewer"})
).execute(&state.db).await?;
```

---

#### 3. Implement Multi-Factor Authentication (MFA)

**Current:** Password-only authentication.

**Fix:**
- Add `mfa_secret` (TOTP seed) and `mfa_enabled` columns to `users` table
- Require TOTP code after password validation
- Use library: `totp-lite` or `google-authenticator`

---

### Medium Priority

#### 4. Key Rotation for RSA Keys

**Current:** No mechanism to rotate user RSA keys.

**Fix:**
- Add `key_version` column to `users` table
- Support multiple public keys per user
- Re-encrypt file keys when user rotates keys

---

#### 5. Content Security Policy (CSP)

**Current:** No CSP headers.

**Fix:**
```rust
// Add middleware in routes.rs
.layer(SetResponseHeaderLayer::if_not_present(
    axum::http::header::CONTENT_SECURITY_POLICY,
    HeaderValue::from_static("default-src 'self'; script-src 'self'; object-src 'none'; base-uri 'self';")
))
```

---

#### 6. Subresource Integrity (SRI) for Frontend

**Current:** Frontend loads crypto libraries without SRI.

**Fix (in gauzian_front):**
```html
<script src="https://cdn.example.com/crypto.js"
        integrity="sha384-..."
        crossorigin="anonymous"></script>
```

---

### Low Priority

#### 7. Implement HSTS Preload

**Current:** HSTS header set by Traefik, but not in preload list.

**Fix:**
- Add `includeSubDomains; preload` to HSTS header
- Submit domain to https://hstspreload.org/

---

## Pre-Deployment Security Checklist

### Infrastructure

- [ ] **Secrets Management**
  - [ ] JWT_SECRET is 256+ bits random
  - [ ] PostgreSQL password is strong (20+ chars, random)
  - [ ] Redis password is set (not default)
  - [ ] MinIO credentials are rotated from defaults
  - [ ] All secrets stored in Kubernetes Secrets (not ConfigMaps)

- [ ] **Network Policies**
  - [ ] Backend can only access PostgreSQL, Redis, MinIO
  - [ ] PostgreSQL is not exposed to public internet
  - [ ] Redis is not exposed to public internet
  - [ ] MinIO console requires authentication

- [ ] **TLS Configuration**
  - [ ] TLS 1.3 enabled
  - [ ] TLS 1.0, 1.1 disabled
  - [ ] Strong cipher suites only (ECDHE, AES-GCM)
  - [ ] Certificate is valid and from trusted CA
  - [ ] Certificate auto-renewal configured (Let's Encrypt)

- [ ] **Kubernetes Security**
  - [ ] Pods run as non-root user
  - [ ] Read-only root filesystem where possible
  - [ ] Resource limits set (CPU, RAM)
  - [ ] Network policies isolate namespaces
  - [ ] RBAC limits pod permissions

---

### Application

- [ ] **Authentication**
  - [ ] Password complexity enforced (min 12 chars, mixed case, numbers, symbols)
  - [ ] Argon2id used for new users (not SHA256)
  - [ ] JWT expiration set to reasonable value (10 days max)
  - [ ] Logout blacklists tokens in Redis
  - [ ] Fail-closed on Redis unavailability

- [ ] **Authorization**
  - [ ] All drive endpoints check file_access/folder_access
  - [ ] IDOR protection via ownership checks
  - [ ] Horizontal privilege escalation prevented
  - [ ] Vertical privilege escalation prevented
  - [ ] Default access level is most restrictive (viewer)

- [ ] **Cryptography**
  - [ ] E2EE implemented correctly (no server-side decryption)
  - [ ] RSA-4096 or higher
  - [ ] AES-256-GCM for file encryption
  - [ ] Random IVs for each encrypted chunk
  - [ ] No hardcoded keys or salts

- [ ] **Input Validation**
  - [ ] All UUIDs validated via `parse_uuid_or_error()`
  - [ ] File sizes checked against quotas
  - [ ] MIME types validated
  - [ ] Email addresses validated (RFC 5322)
  - [ ] Base64 inputs decoded safely

- [ ] **Rate Limiting**
  - [ ] Login endpoint: max 5 attempts per 15 minutes per user
  - [ ] API endpoints: 100 req/s per IP (Traefik)
  - [ ] Upload endpoint: max file size enforced
  - [ ] Folder creation: max depth limit enforced

- [ ] **Logging & Monitoring**
  - [ ] All authentication attempts logged
  - [ ] Failed authorization attempts logged
  - [ ] Prometheus metrics exported
  - [ ] Grafana dashboards configured
  - [ ] Alerts configured for anomalies (high error rate, DB pool exhaustion)

---

### Testing

- [ ] **Security Tests Passed**
  - [ ] SQLMap: No SQL injections found
  - [ ] OWASP ZAP: No high/critical vulnerabilities
  - [ ] k6 load tests: No degradation under expected load
  - [ ] IDOR tests: All unauthorized access attempts blocked
  - [ ] E2EE validation: Server cannot decrypt test files

- [ ] **Penetration Testing**
  - [ ] External pentest conducted (if budget allows)
  - [ ] All findings remediated or accepted risk
  - [ ] Re-test after remediation

---

## Conclusion

This guide provides a comprehensive framework for testing GAUZIAN's security posture. All tests should be run in a staging environment first, then validated in production during off-peak hours with proper authorization.

**Risk Acceptance:** Some vulnerabilities may be accepted risk (e.g., no MFA due to UX impact). Document accepted risks in `SECURITY_RISKS.md`.

**Continuous Testing:** Security is not a one-time effort. Re-run these tests after every major release, dependency update, or infrastructure change.

**Bug Bounty:** Consider launching a bug bounty program (HackerOne, Bugcrowd) to leverage external security researchers.

---

**Next Steps:**
1. Run `./tests/security/run_all_tests.sh` (automated suite)
2. Review results in `tests/security/reports/`
3. Triage findings by severity (Critical → High → Medium → Low)
4. Remediate critical/high findings before production deployment
5. Update `DEVELOPMENT_LOG.md` with security testing results

---

**Contact:** For security concerns, email security@gauzian.pupin.fr (if configured) or report via GitHub Security Advisories.
